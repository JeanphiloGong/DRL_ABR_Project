### **ğŸš€ éƒ¨ç½² DRL æ¨¡å‹åˆ° DASH å®¢æˆ·ç«¯**
ä½ çš„ç›®æ ‡æ˜¯ **è®© DASH.js ä½¿ç”¨ DRL é€‰æ‹©æœ€ä½³ç ç‡ï¼Œè€Œä¸æ˜¯é»˜è®¤çš„ Adaptive Bitrate (ABR) è§„åˆ™**ã€‚  
åœ¨è¿™ä¸€æ­¥ï¼Œä½ éœ€è¦ï¼š
1. **åŠ è½½è®­ç»ƒå¥½çš„ DRL æ¨¡å‹**
2. **ç”¨ DRL é¢„æµ‹ç ç‡**
3. **åœ¨ DASH.js é‡Œæ›¿æ¢é»˜è®¤çš„ ABR ç­–ç•¥**
4. **ç»§ç»­ç›‘æ§å¸¦å®½ã€ç¼“å†²çŠ¶æ€ï¼Œè®°å½•æ—¥å¿—ï¼Œä¼˜åŒ–æ¨¡å‹**

---

## **âœ… 1. åœ¨ Flask æœåŠ¡å™¨åŠ è½½ DRL æ¨¡å‹**
DASH.js éœ€è¦é€šè¿‡ API **è¯·æ±‚ DRL é¢„æµ‹ç ç‡**ï¼Œæ‰€ä»¥ä½ éœ€è¦ä¸€ä¸ª **Flask ç«¯ç‚¹** æ¥å¤„ç†è¯·æ±‚ã€‚

### **ğŸ“Œ 1.1 åŠ è½½ DRL æ¨¡å‹**
ä¿®æ”¹ `server.py`ï¼Œåœ¨ Flask æœåŠ¡å™¨ä¸­æ·»åŠ  **æ¨¡å‹åŠ è½½ & é¢„æµ‹ API**ï¼š
```python
import torch
import torch.nn as nn
import sqlite3
import numpy as np
from flask import Flask, request, jsonify

# åˆå§‹åŒ– Flask
app = Flask(__name__)

# åŠ è½½è®­ç»ƒå¥½çš„ Q-Network
class QNetwork(nn.Module):
    def __init__(self, state_size, action_size):
        super(QNetwork, self).__init__()
        self.fc1 = nn.Linear(state_size, 64)
        self.fc2 = nn.Linear(64, 64)
        self.fc3 = nn.Linear(64, action_size)

    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.relu(self.fc2(x))
        return self.fc3(x)

# ç ç‡é€‰é¡¹ï¼ˆå•ä½ï¼škbpsï¼‰
bitrate_options = [500, 1000, 2500, 5000, 8000]

# åŠ è½½æ¨¡å‹
STATE_SIZE = 5  # (bitrate, buffer, throughput, latency, switch_count)
ACTION_SIZE = len(bitrate_options)
q_network = QNetwork(STATE_SIZE, ACTION_SIZE)
q_network.load_state_dict(torch.load("abr_q_network.pth"))
q_network.eval()

# é¢„å¤„ç†è¾“å…¥æ•°æ®
def normalize(x, min_val, max_val):
    return (x - min_val) / (max_val - min_val)

@app.route('/predict_bitrate', methods=['POST'])
def predict_bitrate():
    try:
        data = request.json
        state = np.array([
            data["bitrate"],
            data["buffer"],
            data["throughput"],
            data["latency"],
            data["switch_count"]
        ], dtype=np.float32)

        # å½’ä¸€åŒ–æ•°æ®
        state[1] = normalize(state[1], 0, 10)  # å‡è®¾ buffer æœ€å¤§å€¼ä¸º 10 ç§’
        state[2] = normalize(state[2], 0, 10000)  # å‡è®¾å¸¦å®½æœ€å¤§å€¼ 10 Mbps
        state[3] = normalize(state[3], 0, 5)  # å‡è®¾æ—¶å»¶æœ€å¤§å€¼ 5s
        state[4] = normalize(state[4], 0, 10)  # ç ç‡åˆ‡æ¢æœ€å¤§å€¼ 10

        # è½¬æ¢ä¸º Tensor
        state_tensor = torch.tensor(state, dtype=torch.float32).unsqueeze(0)

        # é¢„æµ‹ç ç‡
        with torch.no_grad():
            action_idx = torch.argmax(q_network(state_tensor)).item()

        selected_bitrate = bitrate_options[action_idx]
        return jsonify({"bitrate": selected_bitrate})

    except Exception as e:
        return jsonify({"error": str(e)}), 500

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

### **ğŸ“Œ 1.2 å¯åŠ¨ Flask æœåŠ¡å™¨**
```bash
python server.py
```
---

## **âœ… 2. ä¿®æ”¹ DASH.jsï¼Œè®©å®ƒä½¿ç”¨ DRL é¢„æµ‹ç ç‡**
DASH.js **é»˜è®¤ä½¿ç”¨ BOLA/MPC è§„åˆ™**ï¼Œç°åœ¨è¦ **æ›¿æ¢ä¸º DRL é¢„æµ‹çš„ç ç‡**ã€‚

### **ğŸ“Œ 2.1 ä¿®æ”¹ `index.html`**
åœ¨ DASH.js **è¯·æ±‚ä¸‹ä¸€ä¸ªåˆ†ç‰‡æ—¶ï¼Œè°ƒç”¨ Flask æœåŠ¡å™¨** è·å– DRL é¢„æµ‹çš„ç ç‡ã€‚

```html
<!DOCTYPE html>
<html>
<head>
    <script src="https://cdn.dashjs.org/latest/dash.all.min.js"></script>
</head>
<body>
    <video id="videoPlayer" controls></video>
    <script>
        var url = "http://127.0.0.1:8080/dash_content/manifest.mpd";
        var player = dashjs.MediaPlayer().create();
        player.initialize(document.querySelector("#videoPlayer"), url, true);

        // è®°å½•æ—¥å¿—çš„å‡½æ•°
        async function getDrlBitrate() {
            try {
                let dashMetrics = player.getDashMetrics();
                let qualityIndex = player.getQualityFor("video");
                let bitrateInfo = player.getBitrateInfoListFor("video");

                let currentBitrate = bitrateInfo[qualityIndex] ? bitrateInfo[qualityIndex].bitrate : 0;
                let bufferLevel = dashMetrics.getCurrentBufferLevel("video") || 0;
                let throughput = dashMetrics.getCurrentThroughput("video") || 0;
                let latency = dashMetrics.getCurrentLatency("video") || 0;
                let switchCount = dashMetrics.getSwitchRequests("video")?.length || 0;

                let data = {
                    bitrate: currentBitrate,
                    buffer: bufferLevel,
                    throughput: throughput,
                    latency: latency,
                    switch_count: switchCount
                };

                // å‘é€è¯·æ±‚åˆ° DRL æœåŠ¡å™¨
                let response = await fetch("http://127.0.0.1:5000/predict_bitrate", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(data)
                });

                let result = await response.json();
                console.log("DRL é€‰æ‹©çš„ç ç‡:", result.bitrate);
                return result.bitrate;

            } catch (error) {
                console.error("DRL ç ç‡é¢„æµ‹å¤±è´¥:", error);
                return null;
            }
        }

        // æ›¿æ¢ DASH é»˜è®¤çš„ ABR é€»è¾‘
        player.updateSettings({
            streaming: {
                abr: {
                    useDefaultABRRules: false // å…³é—­é»˜è®¤çš„ ABR è§„åˆ™
                }
            }
        });

        // ç›‘å¬ä¸‹ä¸€æ®µè§†é¢‘åŠ è½½å‰ï¼Œè°ƒæ•´ç ç‡
        player.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_PROGRESS, async function () {
            let drlBitrate = await getDrlBitrate();
            if (drlBitrate) {
                let bitrateList = player.getBitrateInfoListFor("video");
                let qualityIndex = bitrateList.findIndex(b => b.bitrate === drlBitrate);

                if (qualityIndex !== -1) {
                    console.log(`è®¾ç½®ç ç‡: ${drlBitrate} (è´¨é‡ç´¢å¼•: ${qualityIndex})`);
                    player.setQualityFor("video", qualityIndex);
                }
            }
        });

    </script>
</body>
</html>
```

---

## **âœ… 3. ç›‘æ§ & è®°å½• DRL ç ç‡åˆ‡æ¢æƒ…å†µ**
åœ¨ `server.py` é‡Œ **å¢åŠ æ—¥å¿—å­˜å‚¨**ï¼Œç”¨äº **åç»­ä¼˜åŒ– DRL æ¨¡å‹**ã€‚

```python
@app.route('/log_drl', methods=['POST'])
def log_drl():
    try:
        data = request.json
        with open("drl_predictions.json", "a") as f:
            json.dump(data, f)
            f.write("\n")
        return jsonify({"status": "logged"})
    except Exception as e:
        return jsonify({"status": "error", "message": str(e)}), 500
```

åœ¨ `DASH.js` é‡Œè°ƒç”¨è¿™ä¸ªæ—¥å¿— APIï¼š
```js
async function logDrlDecision(bitrate) {
    fetch("http://127.0.0.1:5000/log_drl", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ bitrate: bitrate, timestamp: new Date().toISOString() })
    });
}
```

---

## **ğŸš€ æœ€ç»ˆå®ç°**
âœ… **Flask API è®© DASH.js è°ƒç”¨ DRL é¢„æµ‹ç ç‡**  
âœ… **DASH.js æ›¿æ¢é»˜è®¤ ABR é€»è¾‘ï¼Œä½¿ç”¨ DRL é¢„æµ‹ç ç‡**  
âœ… **ç›‘æ§ç ç‡åˆ‡æ¢ï¼Œè®°å½•æ—¥å¿—ï¼Œä¼˜åŒ– DRL è®­ç»ƒ**  

---

## **ğŸš€ ä½ å¯ä»¥è¿™æ ·æµ‹è¯•**
1. **å¯åŠ¨ Flask æœåŠ¡å™¨**
   ```bash
   python server.py
   ```
2. **åœ¨æµè§ˆå™¨æ‰“å¼€ `index.html`**
3. **æŸ¥çœ‹ `F12 > Console`ï¼Œæ£€æŸ¥æ˜¯å¦ä½¿ç”¨ DRL é¢„æµ‹çš„ç ç‡**
4. **æŸ¥çœ‹ `F12 > Network`ï¼Œæ˜¯å¦æŒ‰ DRL é€‰æ‹©çš„ç ç‡åŠ è½½è§†é¢‘**
5. **æ£€æŸ¥ `drl_predictions.json`ï¼Œçœ‹ DRL é€‰æ‹©äº†å“ªäº›ç ç‡**
